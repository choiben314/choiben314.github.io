<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Kandinsky Phased Array — End-to-End Pipeline</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css"
    />
    <style>
      :root {
        --bg: #0b0d11;
        --card: #12151b;
        --ink: #e8eef6;
        --muted: #a7b3c7;
        --accent: #6aa9ff;
        --accent-2: #90e0ef;
        --code-bg: #0f1320;
        --border: #1f2430;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        background: var(--bg);
        color: var(--ink);
        font: 16px/1.55 system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }
      a {
        color: var(--accent);
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 24px;
      }
      header {
        padding: 32px 0 8px;
      }
      h1 {
        font-size: 36px;
        line-height: 1.2;
        margin: 0 0 8px;
        letter-spacing: 0.2px;
      }
      h2 {
        font-size: 24px;
        margin: 28px 0 12px;
        line-height: 1.25;
      }
      h3 {
        font-size: 18px;
        margin: 22px 0 8px;
        color: var(--accent-2);
      }
      p {
        color: var(--ink);
        margin: 12px 0;
      }
      .muted {
        color: var(--muted);
      }
      .author {
        font-size: 14px;
        color: var(--accent);
      }
      .lead {
        font-size: 18px;
        color: var(--muted);
      }
      .cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 16px;
        margin: 20px 0 6px;
      }
      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 16px;
      }
      .stage {
        border-left: 3px solid var(--accent);
        padding-left: 14px;
        margin: 28px 0 8px;
      }
      .figure {
        background: var(--card);
        border: 1px dashed var(--border);
        border-radius: 12px;
        padding: 16px;
        margin: 16px 0;
        text-align: center;
        color: var(--muted);
      }
      .figure img {
        max-width: 100%;
        display: block;
        margin: 4px auto 8px;
        border-radius: 8px;
      }
      .figure small {
        color: var(--muted);
      }
      .two-col {
        display: grid;
        grid-template-columns: 1.1fr 0.9fr;
        gap: 20px;
      }
      pre[class*="language-"] {
        background: var(--code-bg) !important;
        border-radius: 10px;
        border: 1px solid var(--border);
        box-shadow: none !important;
        text-shadow: none !important;
      }
      code[class*="language-"] {
        box-shadow: none !important;
        text-shadow: none !important;
      }
      code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }
      .kbd {
        display: inline-block;
        padding: 2px 6px;
        border: 1px solid var(--border);
        border-bottom-width: 2px;
        border-radius: 6px;
        background: #0b0f1a;
        color: var(--ink);
        font-family: inherit;
        font-size: 0.9em;
      }
      .toc {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 14px;
      }
      .toc a {
        color: var(--muted);
      }
      .meta {
        display: flex;
        gap: 12px;
        align-items: baseline;
        color: var(--muted);
        margin-bottom: 12px;
        font-size: 18px;
      }
      .meta .tag {
        background: #0f1826;
        border: 1px solid var(--border);
        padding: 3px 8px;
        border-radius: 999px;
        color: var(--accent);
      }
      .table {
        width: 100%;
        border-collapse: collapse;
        border: 1px solid var(--border);
        border-radius: 8px;
        overflow: hidden;
      }
      .table th,
      .table td {
        padding: 10px 12px;
        border-bottom: 1px solid var(--border);
      }
      .table th {
        background: #0e1320;
        color: var(--muted);
        font-weight: 600;
        text-align: left;
      }
      .table tr:last-child td {
        border-bottom: none;
      }
      footer {
        color: var(--muted);
        padding: 30px 0 60px;
      }
      .hr {
        height: 1px;
        background: var(--border);
        border: 0;
        margin: 24px 0;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div class="meta">
          <span class="tag">Draft</span>
        </div>
        <h1>48‑Channel Acoustic Imaging — End‑to‑End Pipeline</h1>
        <p class="author">Ben Choi</p>
        <p class="lead">
          From microphone PDM capture on Colorlight 5a-75B FPGA, through UDP transport and
          host‑side decimation, to frequency‑domain cross‑correlation and 3D
          geometry optimization.
        </p>
      </header>

      <section class="toc">
        <strong>Sections</strong>
        <div style="height: 8px"></div>
        <a href="#overview">Overview</a> · <a href="#hardware">Hardware</a> ·
        <a href="#fpga">FPGA PDM → UDP</a> ·
        <a href="#capture">Host Capture & Ring</a> ·
        <a href="#cic">CIC Decimation → PCM</a> ·
        <a href="#ingest">Python Ingest</a> · <a href="#gcc">GCC‑PHAT</a> ·
        <a href="#opt">3D Optimization</a> ·
        <a href="#next">Next Steps</a>
      </section>

      <section id="overview">
        <div class="stage"><h2>Overview</h2></div>
        <p>
          The project implements a low-cost complete acoustic imaging pipeline using a
          48‑channel acoustic phased array (heavily inspired by <a href="https://benwang.dev/2023/02/26/Phased-Array-Microphone.html"
            >Ben Wang's project</a
          >):
        </p>
        <ul>
          <li>
            <strong>48 microphones</strong> arranged radially on a custom PCB,
            generating 1‑bit PDM streams.
          </li>
          <li>
            <strong>FPGA</strong> clocks and samples PDM, packs data, and
            streams via UDP using LiteEth.
          </li>
          <li>
            <strong>Host capture</strong> taps raw Ethernet via macOS
            <span class="kbd">/dev/bpf</span> and writes into a shared memory
            ring.
          </li>
          <li>
            <strong>CIC decimation</strong> converts 1‑bit PDM to multi‑channel
            PCM int32.
          </li>
          <li>
            <strong>GCC‑PHAT</strong> in the frequency domain retrieves robust
            TDOAs per frame.
          </li>
          <li>
            <strong>Nonlinear optimization</strong> (PyTorch) recovers mic
            positions, source trajectory, and speed of sound.
          </li>
        </ul>
        <div class="figure">
          <img src="img_acoustic/assembly.png" alt="Calibration plot" /><small
            >Acoustic phased array assembly</small
          >
        </div>
      </section>

      <section id="hardware">
        <div class="stage"><h2>Hardware: 48‑Mic Circular Array</h2></div>
        <p>
          The array consists of eight arms, each with three pins, and each pin
          carrying two microphones: inner (H) and outer (L). The full array
          exposes 24 stereo lines → <strong>48 channels</strong>.
        </p>
        <div class="cards">
          <div class="card">
            <h3>PCB/Layout</h3>
            <p class="muted">Custom spokes + hub PCBs.</p>
            <div style="display: flex; gap: 16px; align-items: flex-start">
              <div class="figure" style="flex: 1">
                <img
                  src="img_acoustic/hub.png"
                  alt="PCB Spoke"
                  style="width: 100%; max-width: 260px"
                />
                <small>Hub</small>
              </div>
              <div class="figure" style="flex: 1">
                <img
                  src="img_acoustic/spoke.png"
                  alt="PCB Spoke"
                  style="width: 100%; max-width: 260px"
                />
                <small>and Spoke!</small>
              </div>
            </div>
          </div>
        </div>
        <p>
          On the FPGA side, we simply leverage the pin mapping from
          <a
            href="https://github.com/q3k/chubby75/blob/master/5a-75b/hardware_V8.2.md"
            >Chubby75</a
          > of the Colorlight 5a-75B board. The hardest part here was removing the 74HC245 buffer between the
          FPGA and the microphones to enable 3.3V logic inputs and soldering
          tiny flex PCBs (this took a lot of trial and error to do
          consistently).
          <div class="figure">
            <img src="img_acoustic/bypass.png" alt="FPGA Pins" /><small
              >so tiny D:</small
            >
          </div>
        </p>
      </section>

      <section id="fpga">
        <div class="stage"><h2>FPGA: PDM Sampling → UDP Payloads</h2></div>
        <p>
          On‑FPGA logic clocks the shared PDM data line per pin, sampling on
          both edges to separate inner/outer microphones. Words are emitted in
          12‑byte groups: <em>[packet_id, word_prev, word_curr]</em>, repeated
          to fill UDP payloads.
        </p>
        <div class="two-col">
          <div>
            <pre><code class="language-python"># fpga/pdm.py — PDM capture into a 32-bit stream
class PDM(Module):
    def __init__(self, clk_pad, data):
        self.clk_pad = clk_pad
        self.source = stream.Endpoint([("data", 32)])
        count = Signal(4)      # 0..15 (rising/falling edges)
        packet_id = Signal(32)
        data_reg = Signal(24)

        # Capture around edge; emit packet_id then data words
        self.sync += If((count & 7) == 5, data_reg.eq(data))
        self.comb += self.clk_pad.eq(count[-1])  # drive PDM clock

        stmt = If((count & 15) == 0,
                  self.source.data.eq(packet_id),
                  self.source.valid.eq(1),
                  self.source.first.eq(1))
        stmt = stmt.Elif((count & 7) == 1,
                         self.source.data.eq(data_reg),
                         self.source.valid.eq(1),
                         self.source.first.eq(0))
        self.sync += stmt.Else(self.source.valid.eq(0), self.source.first.eq(0))
        self.sync += If((count & 15) == 9, self.source.last.eq(1)).Else(self.source.last.eq(0))
        self.sync += [count.eq(count + 1), If((count & 15) == 15, packet_id.eq(packet_id + 1))]
</code></pre>
          </div>
          <div>
            <pre><code class="language-python"># fpga/pdm.py — UDPStreamer: frames groups into UDP payloads
class UDPStreamer(Module):
    def __init__(self, ip_address, udp_port, data_width=32, fifo_depth=8192):
        self.sink   = stream.Endpoint(eth_tty_tx_description(data_width))
        self.source = stream.Endpoint(eth_udp_user_description(data_width))
        max_packet = 96  # groups per UDP packet
        packet_counter = Signal(max=max_packet+1)
        # FIFO + simple FSM to emit full UDP packets
        # source.length == 3 words/group * 4B * max_packet
        # src/dst ports are identical (loopback style)
</code></pre>
          </div>
        </div>
        <p>
          The UDP path is built on
          <a href="https://github.com/enjoy-digital/liteeth">LiteEth</a>. See
          <code>fpga/main.py</code> for SoC instantiation and port wiring.
        </p>
      </section>

      <section id="capture">
        <div class="stage"><h2>Host Capture: macOS BPF → Shared Ring</h2></div>
        <p>
          On the host, a zero‑copy capture tool uses
          <span class="kbd">/dev/bpf</span> to parse VLAN + IPv4 + UDP, extract
          the packed 12‑byte groups, and write interleaved PCM batches into a
          memory‑mapped ring file for Python to consume.
        </p>
        <pre><code class="language-c">// beamforming/fastcap_pcm.c — ring header and write helper
struct ring_header {
    char magic[8];
    uint32_t version; uint32_t reserved0; uint64_t capacity_bytes;
    _Atomic uint64_t write_pos, read_pos, dropped_by_bpf, blocked_waits;
    uint32_t linktype; uint32_t reserved1;  // LINKTYPE_PCM
};

static void ring_write_pcm_multi(struct ring_header *hdr, uint8_t *data,
    const int32_t *interleaved, size_t frames, size_t channels,
    uint32_t ts_sec, uint32_t ts_usec) {
    // ... writes one aligned record with a small header + payload ...
}
</code></pre>

        <pre><code class="language-c">// IPv4/VLAN/UDP parsing → unpack 3x32-bit groups and feed CIC
if (parse_udp_payload_ipv4_vlan(pkt, caplen, &udp, &udp_len, udp_port)) {
    size_t num_words = udp_len / 4;
    if (num_words &gt;= 3) {
        const uint8_t *wp = udp; size_t frames = num_words / 3;
        for (size_t i = 0; i &lt; frames; i++) {
            uint32_t w_prev = *(uint32_t*)(wp + 4);
            uint32_t w_curr = *(uint32_t*)(wp + 8);
            // run CIC per line, interleave L/H; batch and commit to ring
            // ...
            wp += 12;
        }
    }
}
</code></pre>
        <p>
          Default ring path is <code>/tmp/fastcap_pcm.ring</code>, with
          <em>linktype</em> set to <code>0xFFFF</code> to denote PCM.
        </p>
      </section>

      <section id="cic">
        <div class="stage">
          <h2>CIC Decimation: 1‑bit PDM → Multichannel PCM</h2>
        </div>
        <p>
          Each line carries two PDM streams (outer/inner) captured on alternate
          edges. A parameterizable <strong>CIC</strong> (Cascaded
          Integrator‑Comb) converts the 1‑bit streams into wide dynamic‑range
          PCM.
        </p>
        <pre><code class="language-c">// beamforming/fastcap_pcm.c — 3‑stage CIC with decimation R (default 64)
typedef struct { int stages, R, decim_count; int64_t intL[8], intR[8], combL[8], combR[8]; } CIC;
static bool cic_process_bit(CIC *c, uint32_t bitL, uint32_t bitR, int32_t *outL, int32_t *outH) {
    int64_t vL = cic_integrate(bitL ? 1 : -1, c-&gt;intL, c-&gt;stages);
    int64_t vR = cic_integrate(bitR ? 1 : -1, c-&gt;intR, c-&gt;stages);
    if (++c-&gt;decim_count &lt; c-&gt;R) return false; c-&gt;decim_count = 0;
    int64_t yL = cic_comb(vL, c-&gt;combL, c-&gt;stages);
    int64_t yR = cic_comb(vR, c-&gt;combR, c-&gt;stages);
    return true;
}
</code></pre>
        <p>
          With a PDM clock of ≈3.125&nbsp;MHz and decimation <code>R=64</code>,
          the PCM rate is ≈48.828&nbsp;kHz. The decimator runs per line,
          emitting frames interleaved as <em>L1,H1,L2,H2,…,L24,H24</em>.
        </p>
      </section>

      <section id="ingest">
        <div class="stage">
          <h2>Python Ingest: Ring → WAVs</h2>
        </div>
        <p>Python readers consume the ring and write WAVs.</p>
      </section>

      <section id="gcc">
        <div class="stage"><h2>Time‑Difference Estimation: GCC‑PHAT</h2></div>
        <p>
          Frames are windowed and transformed. Generalized cross‑correlation
          with PHAT weighting produces robust TDOA estimates relative to a
          handful of reference microphones.
        </p>
        <pre><code class="language-python"># beamforming/calibration.py — GCC‑PHAT core
def gcc_phat_tdoa(frames, sample_rate, ref_indices, max_lag_s=0.004):
    T, N, C = frames.shape
    nfft = 1 &lt;&lt; (N - 1).bit_length()
    X = np.fft.rfft(frames, n=nfft, axis=1)           # (T,F,C)
    tdoa = np.zeros((T, len(ref_indices), C), np.float32)
    peak = np.zeros_like(tdoa)
    eps = 1e-12
    for ri, ref in enumerate(ref_indices):
        Xr = X[:, :, ref]
        Rxc = Xr.conj()[:, None, :] * X.transpose(0, 2, 1)
        Rxc /= (np.abs(Rxc) + eps)                     # PHAT
        corr = np.fft.irfft(Rxc, n=nfft, axis=2)
        # fftshift + local window; take argmax for TDOA per channel
        # ...
    return tdoa, peak
</code></pre>
      </section>

      <section id="opt">
        <div class="stage">
          <h2>
            Nonlinear Optimization: Mic Geometry, Source Path, Speed of Sound
          </h2>
        </div>
        <p>
          We jointly optimize microphone positions (48×3), a 3D source
          trajectory over frames, and the speed of sound. The loss penalizes
          TDOA residuals with a Huber term (reduces impact of outliers), while
          regularizing mic positions near the design, enforcing planar mics, and
          smoothing the trajectory.
        </p>
        <pre><code class="language-python"># beamforming/calibration.py — loss sketch
def loss_fn(mic_pos, src_pos, log_c, tdoa, mask, ref_indices):
    c = torch.exp(log_c)
    d = torch.linalg.norm(src_pos[:, None, :] - mic_pos[None, :, :], dim=2)
    d_ref = d[:, ref_indices]
    pred = (d[:, None, :] - d_ref[:, :, None]) / c
    valid = mask.clone();
    for ri, ref in enumerate(ref_indices):
        valid[:, ri, ref] = False
    diff = torch.where(valid, pred - tdoa, torch.zeros_like(pred))
    absd = torch.abs(diff); delta = 2e-4
    huber = torch.where(absd &lt;= delta, 0.5*(absd**2)/delta, absd - 0.5*delta)
    data = huber.sum() / valid.sum().clamp(min=1)
    reg = 5e-3*((mic_pos - mic0)**2).mean() + 2e-3*(mic_pos[:,2]**2).mean()
    return data + reg + 1e-2*jerk_reg(src_pos) + 5e-3*accel_reg(src_pos) + 1e-5*((c-343.0)**2)
</code></pre>
        <div class="figure">
          <img
            src="img_acoustic/calibration_plot.png"
            alt="Calibration plot"
          /><small
            >Output from moving white noise sound source in a spiral
            pattern.</small
          >
        </div>
      </section>

      <section id="next">
        <div class="stage"><h2>Next Steps</h2></div>
        <p>
          The project is a work in progress and there are many things that can
          be improved.
        </p>
        <ul>
          <li>
            We can extend our demo to beamform to focus on the sound source
            using a simple delay and sum beamformer.
          </li>
          <li>
            Build a more rigid assembly + FPGA housing to avoid having to
            recalibrate.
          </li>
          <li>
            Move CIC decimation to FPGA and push the limits of number of
            channels we can handle on standard Gigabit Ethernet.
          </li>
          <li>
            Optimize perf to enable live streaming of the beamformed image to a
            web browser.
          </li>
          <li>
            Adjust TDOA calculation to be pairwise instead of relative to a
            reference microphone.
          </li>
        </ul>
      </section>

      <hr class="hr" />
      <footer>
        <p>
          <strong>Stack</strong>: LiteX/LiteEth, Migen, ECP5, macOS BPF, C11,
          Python/Numpy/PyTorch.
        </p>
        <div style="margin-top: 18px">
          <strong>References</strong>:
          <ul style="color: var(--muted); margin-top: 8px">
            <li>
              <a
                href="https://benwang.dev/2023/02/26/Phased-Array-Microphone.html"
                target="_blank"
                rel="noopener"
                >Acoustic Phased Array Project</a
              >
            </li>
            <li>
              <a
                href="https://blog.yosyshq.com/p/colorlight-part-2/"
                target="_blank"
                rel="noopener"
                >Colorlight 5a-75B Board</a
              >
            </li>
            <li>
              <a
                href="https://tomverbeure.github.io/2021/01/22/The-Colorlight-i5-as-FPGA-development-board.html"
                target="_blank"
                rel="noopener"
                >Colorlight i5 Board</a
              >
            </li>
            <li>
              <a
                href="https://zeromips.org/posts/2022-05-29-5a-75b/"
                target="_blank"
                rel="noopener"
                >74HC245 Bypass</a
              >
            </li>
          </ul>
        </div>
      </footer>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"
      data-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/"
    ></script>
  </body>
</html>
